"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var yeoman = require("yeoman-generator");
var uuid = require("node-uuid");
var glob = require("glob");
var semver = require("semver");
var chalk = require("chalk");
var child_process_1 = require("child_process");
var npmWhich = require("npm-which");
var yosay = require('yosay');
var toPascalCase = require('to-pascal-case');
var isWindows = /^win/.test(process.platform);
var generatorPackageJson = require(path.resolve(__dirname, '../package.json'));
// Paths matching these regexes will only be included if the user wants tests
var testSpecificPaths = [
    /\.spec.ts$/,
    /(^|\/|\\)test($|\/|\\)/ // Files under any directory called 'test'
];
// These NPM dependencies will only be included if the user wants tests
var testSpecificNpmPackages = [
    "@types/chai",
    "@types/jasmine",
    "chai",
    "jasmine-core",
    "karma",
    "karma-chai",
    "karma-chrome-launcher",
    "karma-cli",
    "karma-jasmine",
    "karma-webpack"
];
var optionOrPrompt = require('yeoman-option-or-prompt');
var templates = [
    { value: 'angular', rootDir: 'angular', name: 'Angular', tests: true },
    { value: 'aurelia', rootDir: 'aurelia', name: 'Aurelia', tests: false },
    { value: 'knockout', rootDir: 'knockout', name: 'Knockout', tests: false },
    { value: 'react', rootDir: 'react', name: 'React', tests: false },
    { value: 'react-redux', rootDir: 'react-redux', name: 'React with Redux', tests: false },
    { value: 'vue', rootDir: 'vue', name: 'Vue', tests: false }
];
// Once everyone is on .csproj-compatible tooling, we might be able to remove the global.json files and eliminate
// this SDK choice altogether. That would be good because then it would work with whatever SDK version you have
// installed. For now, we need to specify an SDK version explicitly, because there's no support for wildcards, and
// preview3+ tooling doesn't support project.json at all.
var sdkChoices = [{
        value: '1.0.0-preview2-1-003177',
        name: 'project.json' + chalk.gray(' (compatible with .NET Core tooling preview 2 and Visual Studio 2015)'),
        includeFiles: [/^project.json$/, /\.xproj$/, /_placeholder.txt$/, /\.deployment$/]
    }, {
        value: '1.0.0-preview3-004056',
        name: '.csproj' + chalk.gray('      (compatible with .NET Core tooling preview 3 and Visual Studio 2017)'),
        includeFiles: [/\.csproj$/]
    }];
var MyGenerator = (function (_super) {
    __extends(MyGenerator, _super);
    function MyGenerator(args, options) {
        var _this = _super.call(this, args, options) || this;
        _this._optionOrPrompt = optionOrPrompt;
        _this.log(yosay('Welcome to the ASP.NET Core Single-Page App generator!\n\nVersion: ' + generatorPackageJson.version));
        if (isWindows) {
            assertNpmVersionIsAtLeast('3.0.0');
        }
        return _this;
    }
    MyGenerator.prototype.prompting = function () {
        var _this = this;
        this.option('projectguid');
        var done = this.async();
        this._optionOrPrompt([{
                type: 'list',
                name: 'framework',
                message: 'Framework',
                choices: templates
            }, {
                type: 'list',
                name: 'sdkVersion',
                message: 'What type of project do you want to create?',
                choices: sdkChoices
            }], function (firstAnswers) {
            var templateConfig = templates.filter(function (t) { return t.value === firstAnswers.framework; })[0];
            var furtherQuestions = [{
                    type: 'input',
                    name: 'name',
                    message: 'Your project name',
                    default: _this.appname
                }];
            if (templateConfig.tests) {
                furtherQuestions.unshift({
                    type: 'confirm',
                    name: 'tests',
                    message: 'Do you want to include unit tests?',
                    default: true
                });
            }
            _this._optionOrPrompt(furtherQuestions, function (answers) {
                answers.framework = firstAnswers.framework;
                _this._answers = answers;
                _this._answers.framework = firstAnswers.framework;
                _this._answers.templateConfig = templateConfig;
                _this._answers.sdkVersion = firstAnswers.sdkVersion;
                _this._answers.namePascalCase = toPascalCase(answers.name);
                _this._answers.projectGuid = _this.options['projectguid'] || uuid.v4();
                var chosenSdk = sdkChoices.filter(function (sdk) { return sdk.value === _this._answers.sdkVersion; })[0];
                done();
            });
        });
    };
    MyGenerator.prototype.writing = function () {
        var _this = this;
        var templateConfig = this._answers.templateConfig;
        var templateRoot = this.templatePath(templateConfig.rootDir);
        var chosenSdk = sdkChoices.filter(function (sdk) { return sdk.value === _this._answers.sdkVersion; })[0];
        glob.sync('**/*', { cwd: templateRoot, dot: true, nodir: true }).forEach(function (fn) {
            // Token replacement in filenames
            var outputFn = fn.replace(/tokenreplace\-([^\.\/]*)/g, function (substr, token) { return _this._answers[token]; });
            // Rename template_gitignore to .gitignore in output
            if (path.basename(fn) === 'template_gitignore') {
                outputFn = path.join(path.dirname(fn), '.gitignore');
            }
            // Perform any filename replacements configured for the template
            var mappedFilename = applyFirstMatchingReplacement(outputFn, templateConfig.mapFilenames);
            var fileIsExcludedByTemplateConfig = false;
            if (typeof mappedFilename === 'string') {
                outputFn = mappedFilename;
            }
            else {
                fileIsExcludedByTemplateConfig = (mappedFilename === false);
            }
            // Decide whether to emit this file
            var isTestSpecificFile = testSpecificPaths.some(function (regex) { return regex.test(outputFn); });
            var isSdkSpecificFile = sdkChoices.some(function (sdk) { return sdk.includeFiles.some(function (regex) { return regex.test(outputFn); }); });
            var matchesChosenSdk = chosenSdk.includeFiles.some(function (regex) { return regex.test(outputFn); });
            var emitFile = (matchesChosenSdk || !isSdkSpecificFile)
                && (_this._answers.tests || !isTestSpecificFile)
                && !fileIsExcludedByTemplateConfig;
            if (emitFile) {
                var inputFullPath = path.join(templateRoot, fn);
                var destinationFullPath = _this.destinationPath(outputFn);
                var deleteInputFileAfter = false;
                if (path.basename(fn) === 'package.json') {
                    // Special handling for package.json, because we rewrite it dynamically
                    var tempPath = destinationFullPath + '.tmp';
                    _this.fs.writeJSON(tempPath, rewritePackageJson(JSON.parse(fs.readFileSync(inputFullPath, 'utf8')), _this._answers.tests), 
                    /* replacer */ null, 
                    /* space */ 2);
                    inputFullPath = tempPath;
                    deleteInputFileAfter = true;
                }
                var outputDirBasename = path.basename(path.dirname(destinationFullPath));
                if (outputDirBasename === 'dist') {
                    // Don't do token replacement in 'dist' files, as they might just randomly contain
                    // sequences like '<%=' even though they aren't actually template files
                    _this.fs.copy(inputFullPath, destinationFullPath);
                }
                else {
                    _this.fs.copyTpl(inputFullPath, destinationFullPath, _this._answers);
                }
                if (deleteInputFileAfter) {
                    _this.fs.delete(inputFullPath);
                }
            }
        });
    };
    MyGenerator.prototype.installingDeps = function () {
        var _this = this;
        // If available, restore dependencies using Yarn instead of NPM
        var yarnPath = getPathToExecutable('yarn');
        if (!!yarnPath) {
            this.log('Will restore NPM dependencies using \'yarn\' installed at ' + yarnPath);
            this.npmInstall = function (pkgs, options, cb) {
                return _this.runInstall(yarnPath, pkgs, options, cb);
            };
        }
        this.installDependencies({
            npm: true,
            bower: false,
            callback: function () {
                _this.spawnCommandSync('dotnet', ['restore']);
                _this.spawnCommandSync('./node_modules/.bin/webpack', ['--config', 'webpack.config.vendor.js']);
                _this.spawnCommandSync('./node_modules/.bin/webpack');
            }
        });
    };
    return MyGenerator;
}(yeoman.Base));
function getPathToExecutable(executableName) {
    try {
        return npmWhich(__dirname).sync(executableName);
    }
    catch (ex) {
        return null;
    }
}
function assertNpmVersionIsAtLeast(minVersion) {
    var runningVersion = child_process_1.execSync('npm -v').toString();
    if (!semver.gte(runningVersion, minVersion, /* loose */ true)) {
        console.error("This generator requires NPM version " + minVersion + " or later. You are running NPM version " + runningVersion);
        process.exit(1);
    }
}
function rewritePackageJson(contents, includeTests) {
    if (!includeTests) {
        // Delete any test-specific packages from dependencies and devDependencies
        ['dependencies', 'devDependencies'].forEach(function (dependencyListName) {
            var packageList = contents[dependencyListName];
            if (packageList) {
                testSpecificNpmPackages.forEach(function (packageToRemove) {
                    delete packageList[packageToRemove];
                });
                if (Object.getOwnPropertyNames(packageList).length === 0) {
                    delete contents[dependencyListName];
                }
            }
        });
        // Delete any script called 'test'
        var scripts = contents.scripts;
        if (scripts && scripts.test) {
            delete scripts.test;
            if (Object.getOwnPropertyNames(scripts).length === 0) {
                delete contents.scripts;
            }
        }
    }
    return contents;
}
function applyFirstMatchingReplacement(inputValue, replacements) {
    if (replacements) {
        var replacementPatterns = Object.getOwnPropertyNames(replacements);
        for (var patternIndex = 0; patternIndex < replacementPatterns.length; patternIndex++) {
            var pattern = replacementPatterns[patternIndex];
            var regexp = new RegExp(pattern);
            if (regexp.test(inputValue)) {
                var replacement = replacements[pattern];
                // To avoid bug-prone evaluation order dependencies, we only respond to the first name match per file
                if (typeof (replacement) === 'boolean') {
                    return replacement;
                }
                else {
                    return inputValue.replace(regexp, replacement);
                }
            }
        }
    }
    // No match
    return inputValue;
}
(module).exports = MyGenerator;
